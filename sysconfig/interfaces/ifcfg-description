#	$Id: ifcfg-description,v 1.10.2.5 2001/09/30 10:19:41 misiek Exp $
DEVICE=<name>
[ BOOTMETHOD={none|bootp|dhcp|pump} ]
  You can specify which dhcp client to use with the DHCP_CLIENT, if
  the DHCP_CLIENT is not specified we trying to launch in order :
  /sbin/dhcpcd
  /sbin/dhclient
  /sbin/dhcpxd
  /sbin/pump
  if you have a preferred client define the DHCP_CLIENT variable.
  You can also pass some options to dhcl client via DHCP_OPTIONS.

[ BOOTMETHOD6={none|dhcp6|v4compat}
  dhcp6 method isn't supported, yet.
  v4compat uses available IPv4 addresses (ie. from DHCPv4)
  and then convert them to IPv6 (IPv4-compatible) to use with
  automatic tunnels


IP_1_ADDR="(IPv4 or IPv6 address)/prefix"
IP_1_AOPTS="broadcast xxx etc" (by default broadcast is autocalculated)
IP_1_ROPTS=""

IP_2_ADDR=
IP_2_AOPTS= options for ip addr add
IP_2_ROPTS= options for ip route add (currently used only for IP4_PRIM_NR)

IP4_PRIM_NR="2"		# number X of primary IPv4 interface (IP_X_ADDR)
IP4_SRC_NR="2"		# number X of IPv4 address for ip's ,,src'' parameter
IP6_PRIM_NR=""		# 
IP6_SRC_NR=""		# 

[ ONBOOT={no|yes} ]
[ MULTICAST={|no|yes} ]	- for eth automamaticly set to yes
[ ARP={no|yes} ]	- for eth automamaticly set to yes
[ IPV6_DISABLE_AUTOCONF={yes|no} ] - disable IPv6 autoconfiguration

[ IPX=yes|no ]
if	IPX=yes ; then

	IPXNETNUM_{802_2,802_2TR,802_3,EtherII,SNAP}
	IPXPRIMARY_{802_2,802_2TR,802_3,EtherII,SNAP}=yes|no
	IPXACTIVE_{802_2,802_2TR,802_3,EtherII,SNAP}=yes|no
fi

[ MTU= ]
[ METRIC= ]

[ QDISC= ]

[ DEFAULTHANDLING=yes|no ] (used in configuration for ATM interfaces,
			    obsolete variable)
[ HANDLING=0|1|2|3 ] (0 is default; used ie. in ATM configuration, for
		      details see ifup script)

if 	DEVICE=eth* ; then

	[ MEDIA={auto|10baseT|10base2|AUI} ]
	[ MAC=<hw addres> ]
	
elif	DEVICE=ppp* || DEVICE=sl* ; then
	
	PERSIST=yes|no
	MODEMPORT=<device, say /dev/modem>
	LINESPEED=<speed, say 115200>
	DEFABORT=yes|no 
	
	if	DEVICE=ppp* ; then

		DIRECT_CONNECT=yes|no (dirrect connection without modem ?)
		WVDIALSECT=<section name> from /etc/wvdial.conf; if not set
			   use chat program
		AUTH=yes|no
		PEERDNS=yes|no
		DEFROUTE=yes|no
		ESCAPECHARS=yes|no
	  	HARDFLOWCTL=yes|no ("crtscts" pppd option)
		MODEMCTL=yes|no ("modem" pppd option)
    	 	PPPOPTIONS=<arbitrary option string>
		PAPNAME=<"name $PAPNAME" on pppd command line>
		REMIP=<remote ip4 address, normally unspecified>
		REMIP6=<remote ip6 address, normally unspecified>
    		MRU=
    		INITSCRIPT=<modem command>
		IPV6_PPP=yes|no (IPv6 over ppp)
		if IPV6_PPP = yes ; then
			IPV6_CP_USEV4=yes|no (use local IPv4 mapped addresses
					      as IPv6 addresses)
			IPV6_CP_PERSISTENT=yes|no (use EUI-48 addresses
						   as IPv6 addresses; not
						   supported on Linux, yet)
			or by default use address specified by IP6_PRIM_NR
			and REMIP6
		fi
		IPX_PPP=yes|no
		if IPX_PPP = yes; then
			IPX_PPP_NETWORK=hex net number without leading 0x
			IPX_PPP_NODE=n:m node number
			IPX_PPP_ROUTING=routing protocol
		fi

	elif	DEVICE=sl* ; then	(SLIP)
		DIRECT_CONNECT=yes|no (dirrect connection via slattach ?)
		PROTOCOL=slip|cslip|adaptive
		REMIP=<remote ip4 address>
		REMIP6=<remote ip6 address, normally unspecified>
	fi

elif	DEVICE=br* ; then	/* Bridge */

	BRIDGE_DEVS=<list of devices betwen which do bridging>
		    Note: separation configuration for devices in this list
		          should be avoided !
	AGEING=<ethernet (MAC) address ageing time in seconds>
	GCINT=<garbage collection interval time for the bridge in seconds>

	SPANNING_TREE=yes|no (enable SPT - Spanning Tree Protocol)
	if	SPANNING_TREE=yes ; then
			BRIDGEPRIO=<bridge's priority; 0-65535; less == better>
			FD=<bridge forward delay time in seconds>
			HELLO=<bridge hello time in seconds>
			MAXAGE=<maximum message age in seconds>
			PATHCOST_PORT=<port number>
			PATHCOST=<cost of the port specified in PATHCOST_PORT>
				Note: both PATHCOST_PORT and PATHCOST must be
				      specified to set cost of port
			PORTPRIO_PORT=<port>
			PORTPRIO=<port priority used by port selection algorithms;
			          a number between 0 and 255>
				Note: see note above
	fi

elif	DEVICE=irda* ; then	/* IrDA */
	
	IRDAPORT=<device, say /dev/ttyS1>
	DONGLE=<driver, see README.irattach from irda-utils package>
	DISCOVERY=yes|no (starts discovery of remote IrDA devices)

elif	DEVICE=vlan* ; then	/* Virtual LAN */

	VLAN_DEV=<real VLAN device, ie. eth0>
	
elif	DEVICE=lec* ; then	/* ATM LAME  */

# LANE settings:

	VLAN_NAME=<vlan name to connect to>
	VLAN_FORESWITCH_NAME="$HOSTNAME-$VLAN_NAME"
	LEC_LISTEN_ADDR=<local listen address or selector byte>
	LEC_PHYS=<physical interface number (use to choose card)>
	LANE_VERSION=<LANE version, 1 or 2, LANEv2 is required for MPOA>
	LANE_PROXY=yes|no (enable proxy, used for bridging ATM and ethernet)
	LECS_ADDR=<address of LECS>
	LES_ADDR=<address of LES>
	LEC_MAC=<MAC address to use when communicating in Emulated LAN>
	MTU=1516|1580|4544|9234|18190
	ZEPPELIN_DEBUG_MASK=<0 = No messages, ffff = All messages>

# MPOA settings:

	MPOA_CONTROL=<local ATM address this MPC uses for MPOA
				control connections>
	MPOA_DATA=<local ATM address from and to which MPOA shortcuts
				are established>
	MPOA_MPS=<ATM address of MPS>
	MPOA_MPS_MAC=<MAC address of default router where MPS recides>

elif	DEVICE=atm* ; then	/* ATM CLIP */

# SVC specific options

	ARPSRV_ATMADDR=<ATM address of ATMARP server; omit if local>
	ATMARP_SERVER=yes|no	(is this host an ATM ARP server?)

# PVC specific options

	ATMARP_REMIP=<remote ip4 address, must be specified>
	ATMARP_PVC=<[itf.]vpi.vci>
	ATMARP_NULL=yes|no	(use NULL encapsulation, PVC only)

# General options

	ATMARP_DEFAULT_QOS=<see qos(7)>		# "ubr:max_pcr=700kbps"
	ATMARP_DEFAULT_SNDBUF=<default send buffer size in bytes>
	ATMARP_QOS=<see qos(7)>			# "ubr:max_pcr=100kbps"
	ATMARP_SNDBUF=<send buffer size in bytes>
	ATMARP_TEMP=yes|no	(do not mark the entry as permanent)
	ATMARP_PUB=yes|no	(publishes the entry, for ATMARP server only)
fi
