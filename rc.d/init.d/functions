#!/bin/sh - keep it for file(1) to get bourne shell script result
# functions	This file contains functions to be used by most or all
#		shell scripts in the /etc/init.d directory.
#
# $Id$
#
# Author:	Miquel van Smoorenburg, <miquels@drinkel.nl.mugnet.org>
# Hacked by:	Greg Galloway and Marc Ewing
# Modified for PLD by:
#		Marek Obuchowicz <elephant@pld-linux.org>
#		Arkadiusz Mi¶kiewicz <misiek@pld-linux.org>
#		Micha³ Kochanowicz <mkochano@pld-linux.org>
#		£ukasz Pawelczyk <havner@pld-linux.org>

# First set up a default search path.
export PATH="/sbin:/usr/sbin:/bin:/usr/bin:/usr/X11R6/bin"

# Set defaults
INIT_COL=67

[ -z "${CONSOLETYPE}" ] && CONSOLETYPE="$(/sbin/consoletype)"

# Set colors
RED=1
GREEN=2
YELLOW=3
BLUE=4
MAGENTA=5
CYAN=6
WHITE=7
NORMAL=9
# Bold definition (second parameter to termput setaf)
BOLD=1
NOBOLD=0
# Default colors
CBRACKETS="$CYAN"	# brackets [ ] color
CDONE="$GREEN"		# DONE and WORK color
CBUSY="$MAGENTA"	# BUSY color
CFAIL="$RED"		# FAIL and DIED color
CPOWEREDBY="$CYAN"	# "Powered by" color
CPLD="$GREEN"		# "PLD Linux Distribution" color
CI="$RED"		# Capital I color (press I to enter interactive startup)
CRESMAN="$GREEN"	# "Resource Manager" color
CHARS=""		# Characters displayed on the begining of show line
CCHARS="$NORMAL"	# Color of these characters (look at /etc/sysconfig/init-colors.gentoo example)

# Source configuration if available - may override default values
[ -r /etc/sysconfig/init-colors ] && . /etc/sysconfig/init-colors
[ -r /etc/sysconfig/system ] && . /etc/sysconfig/system

[ -z "$COLUMNS" ] && COLUMNS=80

is_yes()
{
	# Test syntax
	if [ $# = 0 ] ; then
		msg_usage " is_yes {value}"
		return 2
	fi

	# Check value
	case "$1" in
	  yes|Yes|YES|true|True|TRUE|on|On|ON|Y|y|1)
		# true returns zero
		return 0
		;;
	  *)
		# false returns one
		return 1
		;;
	esac
}

is_no()
{
	# Test syntax
	if [ $# = 0 ] ; then
		msg_usage " is_no {value}"
		return 2
	fi

	case "$1" in
	  no|No|NO|false|False|FALSE|off|Off|OFF|N|n|0)
		# true returns zero
		return 0
		;;
	  *)
		# false returns one
		return 1
		;;
	esac
}

if is_yes "$FASTRC"; then
	INIT_DOTS=$(awk "BEGIN{for(\$i=0;\$i<$INIT_COL;\$i++)printf(\".\");}")
	initlog()
	{
		RESULT=0
		while [ "$1" != "${1##-}" ] || [ "$1" != "${1##+}" ]; do
			case $1 in
				-c)
					shift
					$1
					RESULT=$?
					break
					;;
				 *)
					shift
					;;
			esac
		done
		return $RESULT
	}
fi

kernelver()
{
	awk '{split($3,v,"."); printf("%03d%03d%03d\n", v[1],v[2],v[3]);}' /proc/version
}

kernelverser()
{
	awk '{split($3,v,"."); printf("%03d%03d\n", v[1],v[2]);}' /proc/version
}

kernelvermser()
{
	awk '{split($3,v,"."); printf("%03d\n", v[1]);}' /proc/version
}

# Colors workaround
termput()
{
	typeset tputavail

	if [ -d /usr/share/terminfo ] && [ -x /usr/bin/tput -o -x /bin/tput ] ; then
		tputavail=yes
		# check if we are on proper terminal
		tput longname > /dev/null 2>&1 || tputavail=no
	else
		tputavail=no
	fi
	if is_yes "$FASTRC" || is_no "$tputavail" ; then
		case "$1" in
		  hpa)
			echo -ne "\033[$(($2+1))G"
			;;
		  cuu*)
			echo -ne "\033[${2}A"
			;;
		  el)
			echo -ne "\033[0K"
			;;
		  setaf)
			typeset ISBOLD
			if [ -n "$3" ]; then
				ISBOLD="$3"
			else
				ISBOLD="$NOBOLD";
			fi
			is_yes "$COLOR_INIT" && echo -ne "\033[${ISBOLD};3${2}m"
			;;
		  op)
			termput setaf $NORMAL
			;;
		esac
	else
		case "$1" in
		  hpa | cuu* | el)
			tput "$@"
			;;
		  setaf)
			if [ "$3" == "1" ]; then tput bold; else tput sgr0; fi
			is_yes "$COLOR_INIT" && tput setaf "$2"
			;;
		  op)
			termput setaf $NORMAL
			;;
		esac
	fi
}

# printf equivalent
printf_()
{
	typeset text m
	text="$1" ;
	shift ;
	if [ $# -gt 0 ]; then
		m="$1";
		shift;
		while [ $# -gt 0 ]; do
			m="$m\",\"$1" ;
			shift ;
		done
	fi
	awk "BEGIN {printf \"$text\", \"$m\"; }"
}

# National language support function
nls()
{
	typeset msg_echo old_nls_domain text message
	msg_echo='\n'
	old_nls_domain="$NLS_DOMAIN"
	# parse command line
	# don't use -o instead || here - this will break ksh --misiek
	while [ "$1" != "${1##-}" ] || [ "$1" != "${1##+}" ]; do
		case "$1" in
		  --nls-domain)
			shift
			NLS_DOMAIN="$1"
			shift
			;;
		  -n)
			msg_echo=''
			shift
			;;
		esac
	done
	message="$1"
	shift
	# empty message, so we return --misiek
	if [ -z "$message" ]; then
		NLS_DOMAIN="$old_nls_domain"
		echo -en "$msg_echo"
		return
	fi

	if is_yes "$FASTRC"; then
		printf "$message" "$@"
	elif [ -x /bin/gettext -o -x /usr/bin/gettext ]; then
		text=$(TEXTDOMAINDIR="/etc/sysconfig/locale" gettext -e --domain="${NLS_DOMAIN:-rc-scripts}" "$message")
		printf_ "$text" "$@"
	else
		printf_ "$message" "$@"
	fi

	echo -en "$msg_echo"
	NLS_DOMAIN="$old_nls_domain"
}

rc_splash()
{
	return
}

msg_network_down()
{
	nls "ERROR: Networking is down. %s can't be run." "$1" >&2
}

msg_starting()
{
	show "Starting %s service" "$1"
}

msg_already_running()
{
	nls "%s service is already running." "$1"
}

msg_stopping()
{
	show "Stopping %s service" "$1"
}

msg_not_running()
{
	nls "%s service is not running." "$1"
}

msg_reloading()
{
	show "Reloading %s service" "$1"
}

msg_usage()
{
	nls "Usage: %s" "$*"
}

# Some functions to handle PLD-style messages
show()
{
	typeset text

	if is_yes "$FASTRC"; then
		echo -n "$INIT_DOTS"
		termput hpa 0
		if [ -n "$CHARS" ]; then
	                termput setaf $CCHARS
			echo -n "$CHARS"
			termput op
		fi
		printf "$@"
		termput hpa $INIT_COL
	else
		text=$(nls "$@")
		if [ -n "$CHARS" ]; then
	                termput setaf $CCHARS
			echo -n "$CHARS"
			termput op
		fi
		echo -n "$text"
		awk "BEGIN { for (j=length(\"$CHARS$text\"); j<$INIT_COL; j++) printf \".\" }"
	fi
}

# Displays message in square brackests ("[ DONE ]"). Takes two arguments.
# First is the text to display, second is color number to use (argument to
# tput setaf). If second argument is not given, default (2, green) will be
# used).
progress()
{
	typeset COLOR
	if [ -n "$2" ]; then COLOR="$2"; else COLOR="$CDONE"; fi
	deltext
	echo -n "$(termput setaf $CBRACKETS)[$(termput setaf $COLOR) $(nls --nls-domain rc-scripts "$1") $(termput setaf $CBRACKETS)]$(termput op)"
}

busy()
{
	progress "BUSY" "$CBUSY"
}

ok()
{
	progress "DONE"
	echo
}

started()
{
	progress "WORK"
	echo
}

fail()
{
	progress "FAIL" "$CFAIL"
	echo
	return 1
}

died()
{
	progress "DIED" "$CFAIL"
	echo
	return 1
}

deltext()
{
	termput hpa $INIT_COL
}

# Check if $pid (could be plural) are running
checkpid()
{
	while [ "$1" ]; do
		[ -d "/proc/$1" ] && return 0
		shift
	done
	return 1
}

# outside chroot get only those processes, which are outside chroot.
# inside chroot get only those processes, which are inside chroot.
# (note: some processes like named are chrooted but run outside chroot)
filter_chroot()
{
	if [ $# -lt 1 -o ! -d /proc/1 ] ; then
		echo $@
		return
	fi
        good_pids=""
	for root_pid in $@; do
		root_dir=$(resolvesymlink /proc/${root_pid}/root)
		if [ -n "$root_dir" ]; then
			good_add_pid=1
			if [ -n "${SYSTEM_CHROOTS}" ]; then
				for r_dir in ${SYSTEM_CHROOTS}; do
					echo "$root_dir" | grep -q "^${r_dir}" && good_add_pid=0
				done
			fi
			[ "$good_add_pid" -eq 1 ] && good_pids="$good_pids $root_pid"
		fi
	done
	echo $good_pids
}

# Usage run_cmd Message command_to_run
run_cmd()
{
	typeset exit_code errors message force_err
	typeset -i force_err=0
	typeset -i exit_code=0
	case "$1" in
	  -a)
		force_err=1
		shift
		;;
	esac
	message=$1
	show "$message"; busy
	shift
	cd /
	if errors=$(HOME=/tmp TMPDIR=/tmp initlog -c "$*" 2>&1); then
		ok
		log_success "$1 $message"
	else
		fail
		log_failed "$1 $message"
		exit_code=1
	fi
	[ -n "$errors" ] && [ $exit_code -eq 1 -o $force_err -eq 1 ] && echo "$errors"
	return $exit_code
}

# A function to start a program (now it's useful on read-only filesystem too)
daemon()
{
	typeset errors="" prog="" limits="" waitname="" waittime=""
	typeset -i exit_code=0
	[ -z "$DEFAULT_SERVICE_RUN_NICE_LEVEL" ] && DEFAULT_SERVICE_RUN_NICE_LEVEL=0
	# "-u unlimited" (-p for ksh) to make sure daemons will be able to fork.
	# "-c 0" to make sure it doesn't core dump anywhere; while this could mask
	# problems with the daemon, it also closes some security problems.
	# Users' limits are set via pam_limits.
	[ -z "$DEFAULT_SERVICE_LIMITS" ] && DEFAULT_SERVICE_LIMITS_HARD="-u unlimited -c 0"
	# Test syntax. Don't use -o instead || here - this will break ksh --misiek
	while [ "$1" != "${1##-}" ] || [ "$1" != "${1##+}" ]; do
		case $1 in
		  '')
			msg_usage " daemon [--user user] [--fork] [+/-nicelevel] {program}"
			return 2
			;;
		  --check)
			# for compatibility with redhat/mandrake
			nls "warning: --check option is ignored!"
			shift
			shift
			;;
		  --user)
			shift
			[ "$1" != "root" ] && prog="/bin/su $1 -s /bin/sh -c \""
			shift
			;;
		  --fork)
			prog="/usr/bin/setsid sh -c \""
			end='&'
			shift
			;;
		  --waitforname)
			shift
			waitname="$1"
			shift
			;;
		  --waitfortime)
			shift
			waittime="$1"
			shift
			;;
		  -*|+*) SERVICE_RUN_NICE_LEVEL=$1
			shift
			;;
		esac
	done
	# If command to execute ends with quotation mark, add remaining
	# arguments and close quotation.
	if [ "$prog" != "${prog%\"}" ]; then
		prog="$prog $*$end\""
	else
		prog="$prog $*$end"
	fi

	if [ -n "$KSH_VERSION" ]; then
		limits="`echo "${SERVICE_LIMITS:-$DEFAULT_SERVICE_LIMITS}" | awk '/-Su/ {sub(/-Su/,"-Sp");} /-Hu/ {sub(/-Hu/,"-Hp");} /-u/ {sub(/-u/,"-p");} {print;}'`"
	elif [ -n "$ZSH_VERSION" ]; then
		limits="${SERVICE_LIMITS:-$DEFAULT_SERVICE_LIMITS}"
	elif [ -n "$BASH_VERSION" ]; then
		limits="${SERVICE_LIMITS:-$DEFAULT_SERVICE_LIMITS}"
#	elif [ -n "`$SH -c 'echo ${.sh.version}' 2>/dev/null`" ]; then
	fi

	[ -n "$limits" ] && eval `echo "$limits" | awk 'BEGIN {RS="[\n-]";} !/^ *$/ { printf("ulimit -%s ;", $0); }'`

	[ -z "$DEFAULT_SERVICE_UMASK" ] && DEFAULT_SERVICE_UMASK=022

	# And start it up.
	busy
	cd /
	if errors=$(umask ${SERVICE_UMASK:-$DEFAULT_SERVICE_UMASK}; USER=root HOME=/tmp TMPDIR=/tmp nice -n ${SERVICE_RUN_NICE_LEVEL:-$DEFAULT_SERVICE_RUN_NICE_LEVEL} initlog -c "$prog" 2>&1); then
		if [ -n "$waitname" -a -n "$waittime" ]; then
			# Save basename.
			base=$(basename "$waitname")
			# Find pid.
			pid=$(pidofproc "$waitname" "$pidfile")
			[ -z "$pid" ] && pid=$(pidofproc "$base" "$pidfile")
			i=0
			while [ "$i" -lt "$waittime" ]; do
				i=$(( i + 1 ))
				checkpid $pid && sleep 1 || break
			done
		fi
		log_success "$1 startup"
		ok
	else
		exit_code=1
		fail
		log_failed "$1 startup"
		[ -n "$errors" ] && echo "$errors"
	fi
	return $exit_code
}

# A function to stop a program.
killproc()
{
	typeset notset killlevel base pid pidfile result
	# Test syntax.
	if [ $# = 0 ]; then
		msg_usage " killproc {program} [signal]"
		return 2
	fi

	while [ "$1" != "${1##-}" ] || [ "$1" != "${1##+}" ]; do
		case $1 in
			--pidfile)
				shift
				pidfile="$1"
				shift
			;;
			--waitforname)
                        	shift
                        	waitname="$1"
                        	shift
			;;
                  	--waitfortime)
                        	shift
                        	waittime="$1"
                        	shift
			;;
		esac
	done

	busy

	typeset -i notset=0
	# check for second arg to be kill level
	if [ -n "$2" ] ; then
		killlevel=$2
	else
		notset=1
		killlevel="-9"
	fi

	# Save basename.
	base=$(basename "$1")

	# Find pid.
	pid=$(pidofproc "$1" "$pidfile")
	[ -z "$pid" ] && pid=$(pidofproc "$base" "$pidfile")

	# Kill it.
	if [ -n "$pid" -a "$pid" != "$$" ] && checkpid $pid 2>&1 ; then
		if [ "$notset" = "1" ] ; then
			if checkpid $pid 2>&1; then
				# TERM first, then KILL if not dead
				kill -TERM $pid
				usleep 100000
				if checkpid $pid && sleep 1 &&
					checkpid $pid && sleep 3 &&
					checkpid $pid; then
					kill -KILL $pid
					usleep 100000
				fi
			fi
			checkpid $pid
			result=$?
			if [ "$result" -eq 0 ]; then
				fail
				log_failed "$1 shutdown"
			else
				ok
				log_success "$1 shutdown"
			fi
			result=$(( ! $result ))
		else
			# use specified level only
			if checkpid $pid > /dev/null 2>&1; then
				kill $killlevel $pid
				result=$?
				if [ "$result" -eq 0 ]; then
					ok
					log_success "$1 got $killlevel"
				else
					result=7
					fail
					log_failed "$1 didn't get $killlevel"
				fi
			else
				result=7
				died
				log_failed "$1 shutdown"
			fi
		fi
	else
		died
		log_failed "$1 shutdown"
		result=7
	fi
	
	if [ -n "$waitname" -a -n "$waittime" ]; then
		# Save basename.
		base=$(basename "$waitname")
		# Find pid.
		pid=$(pidofproc "$waitname" "$pidfile")
		[ -z "$pid" ] && pid=$(pidofproc "$base" "$pidfile")
		i=0
		while [ "$i" -lt "$waittime" ]; do
			i=$(( i + 1 ))
			checkpid $pid && sleep 1 || break
		done
	fi

	# Remove pid file if any.
	if [ "$notset" = "1" ]; then
		rm -f /var/run/${base}.pid
	fi

	return $result
}

# A function to find the pid of a program.
pidofproc()
{
	typeset pid pidfile base
	base=$(basename "$1")
	pidfile="$base.pid"
	[ -n "$2" ] && pidfile="$2"

	# Test syntax.
	if [ $# = 0 ] ; then
		msg_usage " pidofproc {program}"
		return 2
	fi

	# First try pidfile or "/var/run/*.pid"
	if [ -f /var/run/${pidfile} ] ; then
		typeset line p pid
		pid=
		read line < /var/run/${pidfile}
		for p in $line; do
			[ -z "$(echo "$p" | awk '{gsub(/[0-9]/,"");print;}')" ] && pid="$pid $p"
		done
	fi

	# Next try "pidof"
	[ -z "$pid" ] && pidof -o $$ -o $PPID -o %PPID -x "$1"
	pid=$(filter_chroot "$pid")
	echo $pid
}

status()
{
	typeset base pid subsys daemon
	subsys=$1
	daemon=${2:-$subsys}
	base=$(basename $daemon)

	# Test syntax.
	if [ $# = 0 ] ; then
		msg_usage " status {subsys} [{daemon}]"
		return 2
	fi

	# First try "pidof"
	pid=$(pidof -o $$ -o $PPID -o %PPID -x $daemon)
	pid=$(filter_chroot "$pid")

	if [ "$pid" != "" ]; then
		nls "%s (pid %s) is running..." "$daemon" "$pid"
		return 0
#	else
#		pid=`ps ax | awk 'BEGIN { prog=ARGV[1]; ARGC=1 }
#		     { if ((prog == $5) || (("(" prog ")") == $5) ||
#		          (("[" prog "]") == $5) ||
#		          ((prog ":") == $5)) { print $1 ; exit 0 } }' $1`
#		if [ "$pid" != "" ]; then
#			nls "%s (pid %s) is running..." "$daemon" "$pid"
#			return 0
#		fi
	fi

	# Next try "/var/run/*.pid" files
	if [ -f /var/run/${base}.pid ]; then
		read pid < /var/run/${base}.pid
		pid=$(filter_chroot "$pid")
		if [ "$pid" != "" ]; then
			nls "%s dead but pid file exists" "$subsys"
			return 1
		fi
	fi

	# See if /var/lock/subsys/$subsys exists
	if [ -f /var/lock/subsys/$subsys ]; then
		nls "%s dead but subsys locked" "$subsys"
		return 2
	fi
	nls "%s is stopped" "$subsys"
	return 3
}

# Confirm whether we really want to run this service
confirm() {
	return 0
}

# module is needed (ie. is requested, is available and isn't loaded already)
is_module()
{
	# module name without .o at end
	if ! (lsmod | grep -q "$1"); then
		if (ls -R /lib/modules/$(uname -r)/ 2> /dev/null | grep -q "${1}.\(\|k\)o\(\|.gz\)"); then
			# true
			return 0
		fi
	fi
	# false
	return 1
}

_modprobe()
{
	typeset parsed single die args foo result
	parsed=no
	while is_no "$parsed" ; do
		case "$1" in
		  "single")
			single=yes
			shift
			;;
		  "die")
			die=yes
			shift
			;;
		  -*)
			args="$args $1"
			shift
			;;
		  *)
			parsed=yes
			;;
		esac
	done
	if is_yes "${single}" ; then
		foo="$@"
		show "Loading %s kernel module(s)" "$foo"
		busy
	fi
	if [ -x /sbin/modprobe ] ; then
		/sbin/modprobe -s $args "$@"
		result=$?
	else
		deltext ; fail
		result=1
	fi
	if is_yes "${single}" ; then
		deltext
		if [ $result == "0" ] ; then
			is_yes "$single" && ok
		else
			fail
			if is_yes "$die" ; then
				nls "Could not load %s kernel module(s)" "$@"
				exit 1
			fi
		fi
	fi
}

log_success ()
{
	initlog -n $0 -s "$1 $2" -e 1
}

log_failed ()
{
	initlog -n $0 -s "$1 $2" -e 2
}

# RedHat/Mandrake specific functions
action () { STRING=$1; shift; run_cmd "$STRING" "$*"; }
success () { return 0; }
failure () { return 1; }

disable_selinux() {
	selinuxfs=`awk '/ selinuxfs / { print $2 }' /proc/mounts`
	echo "*** Warning -- SELinux is active"
	echo "*** Disabling security enforcement for system recovery."
	echo "*** Run 'setenforce 1' to reenable."
	echo "0" > $selinuxfs/enforce
}

relabel_selinux() {
	selinuxfs=`awk '/ selinuxfs / { print $2 }' /proc/mounts`
	echo "
         *** Warning -- SELinux relabel is required. ***
         *** Disabling security enforcement.         ***
         *** Relabeling could take a very long time, ***
         *** depending on file system size.          ***
         "
    	echo "0" > $selinuxfs/enforce
    	/sbin/fixfiles -F relabel > /dev/null 2>&1
    	rm -f  /.autorelabel
    	echo "*** Enabling security enforcement.         ***"
    	echo $SELINUX > $selinuxfs/enforce
}

#/*
# * Local variables:
# * mode: sh
# * indent-tabs-mode: notnil
# * End:
# *
# */
# vi: syntax=sh:shiftwidth=8:
