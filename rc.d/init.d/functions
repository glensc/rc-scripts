# functions	This file contains functions to be used by most or all
#		shell scripts in the /etc/init.d directory.
#
# $Id: functions,v 1.13 1999/07/13 12:49:36 misiek Exp $
#
# Author:	Miquel van Smoorenburg, <miquels@drinkel.nl.mugnet.org>
# Hacked by:    Greg Galloway and Marc Ewing
# Modified for PLD by:
#		Marek Obuchowicz <elephant@shadow.eu.org>
#		Arkadiusz Mi¶kiewicz <misiek@pld.org.pl> 

# First set up a default search path.
export PATH="/sbin:/usr/sbin:/bin:/usr/bin:/usr/X11R6/bin"

[ -z "$COLUMNS" ] && COLUMNS=80

# Colors workaround
unset tput || :
if [ "$COLOR_INIT" == "no" ]; then
        tput()
        {
        :
        }
elif [ ! -d /usr/share/terminfo ]; then
        tput()
        {
                if [ "$2" == "1" ]; then echo -ne "\033[0;31m"
                elif [ "$2" == "2" ]; then echo -ne "\033[0;32m"
                elif [ "$2" == "5" ]; then echo -ne "\033[0;35m"
                elif [ "$2" == "6" ]; then echo -ne "\033[0;36m"
                elif [ "$2" == "7" ]; then echo -ne "\033[0;37m"
                fi
        }
else
unset tput || :
fi

# Some functions to handle PLD-style messages
show() 
{
	text="$*"..................................................................................
	printf "%.65s" $text
}

busy() 
{
	echo -n "`tput setaf 6`[`tput setaf 5` BUSY `tput setaf 6`]`tput setaf 7`"
}

ok() 
{
	echo  "`tput setaf 6`[`tput setaf 2` DONE `tput setaf 6`]`tput setaf 7`"
}

started()
{
	echo  "`tput setaf 6`[`tput setaf 2` WORK `tput setaf 6`]`tput setaf 7`"
}

fail() 
{
	echo  "`tput setaf 6`[`tput setaf 1` FAIL `tput setaf 6`]`tput setaf 7`"
}

died() 
{
	echo  "`tput setaf 6`[`tput setaf 1` DIED `tput setaf 6`]`tput setaf 7`"
}

deltext() 
{
	echo -ne '\b\b\b\b\b\b\b\b'
}

# Usage run_cmd Message command_to_run
run_cmd()
{
	_ERRORS=""
	MESSAGE=$1
	show "$MESSAGE"; busy
	shift
	if _ERRORS="`initlog -c \"$*\"`"; then
		deltext; ok
	else
		deltext; fail; echo $_ERRORS
	fi
	exit_code=$?
	unset _ERRORS
	return $exit_code
}

# A function to start a program (now it's usefull on read-only filesystem too)
daemon() 
{
	nicelevel=0
	_ERRORS=""
	[ -z "$DEFAULT_SERVICE_RUN_NICE_LEVEL" ] && DEFAULT_SERVICE_RUN_NICE_LEVEL=0
	# Test syntax.
	case $1 in
	'')	echo '$0: Usage: daemon [+/-nicelevel] {program}'
		return 1;;
	-*|+*) SERVICE_RUN_NICE_LEVEL=$1
		shift;;
	esac

	# make sure it doesn't core dump anywhere; while this could mask
	# problems with the daemon, it also closes some security problems
	ulimit -c 0

	# And start it up.
	busy
	if _ERRORS="`nice -n ${SERVICE_RUN_NICE_LEVEL:-$DEFAULT_SERVICE_RUN_NICE_LEVEL} initlog -c "$*" 2>&1`"; then
		deltext
		ok
	else
		deltext
		fail
		echo $_ERRORS
	fi
	unset _ERRORS
}

# A function to stop a program.
killproc() 
{
	# Test syntax.
	if [ $# = 0 ]; then
		echo "Usage: killproc {program} [signal]"
		return 1
	fi

	busy
	
	TMPFILE=`mktemp /tmp/init-XXXXXX`
	
	notset=0
	# check for second arg to be kill level
	if [ "$2" != "" ] ; then
		killlevel=$2
	else
		notset=1
		killlevel="-9"
	fi

        # Save basename.
        base=`basename $1`

        # Find pid.
        pid=`pidofproc $base`

        # Kill it.
        if [ "$pid" != "" ] ; then
		if [ "$notset" = 1 ] ; then
			# TERM first, then KILL if not dead
			kill -TERM $pid >$TMPFILE 2>&1
			usleep 100000
			dead=`ps -o pid= $pid`
			if [ "$dead" != "" ]; then
				sleep 3
				kill -KILL $pid >$TMPFILE 2>&1
			fi
		# use specified level only
		else
	                kill $killlevel $pid >$TMPFILE 2>&1
		fi
	else
		rm -f /var/run/$base.pid
		deltext
		fail
		return
	fi

        # Remove pid file if any.
        rm -f /var/run/$base.pid
	
	if [ -z "`cat $TMPFILE`" ]; then
		deltext
		ok
	else
		deltext
		died	
	fi
	rm -f $TMPFILE
}

# A function to find the pid of a program.
pidofproc() 
{
	# Test syntax.
	if [ $# = 0 ] ; then
		echo "Usage: pidofproc {program}"
		return 1
	fi

	# First try "/var/run/*.pid" files
	if [ -f /var/run/$1.pid ] ; then
	        pid=`head -1 /var/run/$1.pid`
	        if [ "$pid" != "" ] ; then
	                echo $pid
	                return 0
	        fi
	fi

	# Next try "pidof"
	#pid=`pidof $1`
	if [ "$pid" != "" ] ; then
	        echo $pid
	        return 0
	fi

	# Finally try to extract it from ps
	pids=`ps -C $1 -o pid=`

	# Return the first PID, which is not our
	for pid in $pids ; do
		if [ $pid != $$ ] ; then
	  		echo $pid
			return 0
		fi
	done  
	
	return 1
}

status() 
{
	# Test syntax.
	if [ $# = 0 ] ; then
		echo "Usage: status {program}"
		return 1
	fi

	# First try "pidof"
	pid=`pidof $1`
	if [ "$pid" != "" ] ; then
	        echo "$1 (pid $pid) is running..."
	        return 0
        else
                pid=`echo \`ps -C $1 -o pid= \``
                if [ "$pid" != "" ] ; then
                        echo  "$1 (pid $pid) is running..."
                        return 0
                fi
	fi

	# Next try "/var/run/*.pid" files
	if [ -f /var/run/$1.pid ] ; then
	        pid=`head -1 /var/run/$1.pid`
	        if [ "$pid" != "" ] ; then
	                echo "$1 dead but pid file exists"
	                return 1
	        fi
	fi
	# See if /var/lock/subsys/$1 exists
	if [ -f /var/lock/subsys/$1 ]; then
		echo "$1 dead but subsys locked"
		return 2
	fi
	echo "$1 is stopped"
	return 3
}
