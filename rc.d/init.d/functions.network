#
# $Id: functions.network,v 1.44 2000/06/27 20:22:34 baggins Exp $
# 
# This is not a shell script; it provides functions to network scripts
# that source it.

# This will work only after starting interface to which LDAP server is connected
find_ldap_interfaces()
{
is_yes "$USE_LDAP" && [ -x /usr/bin/ldapsearch ] || exit 1
if [ -n "$LDAP_BASE_DN" ] ; then
	BSWITCH="-b$LDAP_BASE_DN" 
else
	BSWITH=""
fi

QUERY="(&(objectclass=pldinterface)(if_onboot=yes))"
ldapsearch "$BSWITCH" "$QUERY" if_device | \
	grep "^if_device=" | sed -e "s/^if_device=//"
}

# find aliases for device
find_ldap_aliases()
{
is_yes "$USE_LDAP" && [ -x /usr/bin/ldapsearch ] || exit 1
if [ -n "$LDAP_BASE_DN" ] ; then
	BSWITCH="-b$LDAP_BASE_DN" 
else
	BSWITH=""
fi

QUERY="(&(objectclass=pldinterface)(if_onboot=yes)(if_device~=$1:*))"
ldapsearch "$BSWITCH" "$QUERY" if_device | \
	grep "^if_device=" | sed -e "s/^if_device=//"
}

get_ldap_config ()
{
if is_yes "$USE_LDAP" && [ -x /usr/bin/ldapsearch ]; then
	exit 1
fi

# Initialise fields which  can have multiple values:
IPV6_ADDR=""
IPADDR_ALIASES=""

QUERY="(&(objectclass=pldinterface)(if_device=$1))"
if [ -n "$LDAP_BASE_DN" ] ; then
	BSWITCH="-b$LDAP_BASE_DN" 
else
	BSWITH=""
fi

ldapsearch "$BSWITCH" "$QUERY" | grep "=" | sed -e "s/=/ /" | {
	while read FIELD VALUE ; do
		# Field, which have name compatible with other 
		# LDAP object
		if [ "$FIELD" = "iphostnumber" ] ; then
			VAR="IPADDR";
		else # Other fields
			VAR=`echo "$FIELD" | grep "^if_" \
			     | tr [:lower:] [:upper:] \
			     | sed -e "s/IF_//"`
		fi
		# Fields which can have multiple values:
		if   [ "$VAR" = "IPV6_ADDR" \
		    -o "$VAR" = "IPADDR_ALIASES" ]  && \
		     [ -n "`eval echo \$$VAR`" ] ; then
			echo "$VAR=\"\$$VAR $VALUE\"" ;

		# single value fields, or the first value
		elif [ -n "$VAR" ] ; then
			eval "$VAR=\"$VALUE\""
			echo "$VAR=\"$VALUE\""
		fi
	done
}
}

source_config ()
{
DEVNAME="`basename "$CONFIG" | sed 's/^ifcfg-//g'`"
        
if echo "$CONFIG"|egrep "^/" >/dev/null 2>&1 ; then
	if [ -f "$CONFIG" ] ; then
		. "$CONFIG"
	fi
elif [ -f "/etc/sysconfig/interfaces/$CONFIG" ] ; then
	. "/etc/sysconfig/interfaces/$CONFIG"
elif is_yes "$USE_LDAP"; then
	eval `get_ldap_config $DEVNAME`
fi
}

do_netreport ()
{
# Notify programs that have requested notification
( cd /var/run/netreport || exit
for i in * ; do
	[ -f $i ] && \
		kill -SIGIO $i >/dev/null 2>&1 || \
		rm -f $i >/dev/null 2>&1
done
)
}

need_hostname()
{
if [ "`hostname`" = "(none)" -o "`hostname`" = "localhost" -o \
	"`hostname`" = "localhost.localdomain" ]; then
	NEEDHOSTNAME=yes
else
	unset NEEDHOSTNAME
fi
}

set_hostname()
{
hostname=`echo $1 | sed 's/\..*$//'`
domain=`echo $1 | sed 's/^[^\.]*\.//'`

if [ -n "$hostname" ] ; then
	echo "$hostname" > /etc/HOSTNAME
	hostname $hostname
fi	

if [ -n "$domain" ] ; then
	>/etc/resolv.conf.new
	if ! grep -q "search $domain" /etc/resolv.conf ; then
		echo "search $domain" >> /etc/resolv.conf.new
	fi
	echo "domain $domain" >> /etc/resolv.conf.new
	grep -v "^domain " /etc/resolv.conf >> /etc/resolv.conf.new
	mv -f /etc/resolv.conf.new /etc/resolv.conf
fi
}

# PLD/Linux network functions
# Copyright (C) 1999, 2000 Arkadiusz Mi¶kiewicz <misiek@pld.org.pl>

# All functions must be called "name_of_function on" or "name_of_function off"

# Setup Network Address Translation (NAT)
setup_nat()
{
if [ -r /etc/sysconfig/static-nat ]; then
	grep "^[0-9]" /etc/sysconfig/static-nat | while read src via dst; do
		if [ "$1" = "on" ]; then
			/sbin/ip route add nat $src via $dst
			/sbin/ip rule add from $dst nat $src
		elif [ "$1" = "off" ]; then
			/sbin/ip rule del from $dst nat $src
			/sbin/ip route del nat $src via $dst
	fi
	done
fi
}

# network router discovery daemon
rdisc()
{
if is_yes "$IPV6_NETWORKING"; then
  [ -z "$IPV6_RDISC_MODE" ] && IPV6_RDISC_MODE=host
  if is_yes "$IPV6_RDISC"; then
  RDISC_OPTS="-fs"
	case "$1" in
	on|start)
		[ "$IPV6_RDISC_MODE" = "router" ] && \
		RDISC_OPTS="$RDISC_OPTS -r"
		run_cmd "Starting network router discovery daemon" \
			/usr/sbin/rdisc $RDISC_OPTS
		;;
	off|stop)
		msg_stopping "network router discovery daemon"
		killproc rdisc -HUP
		;;
	esac
  fi
fi
}

# proc_net <zmien> <start/stop> <co ustaw> <co default> <nazwa_zmiennej> [komunikat]
# proc_net ipv4/ip_forward start 1         0            IPV4_FORWARDING  "IPv4 forwarding"
#
# wy¶wietli siê komunikat "Setting IPv4 forwarding to 1"
# je¶li nie podano komunikatu nic nie jest wy¶wietlane

proc_net()
{
WHAT="$1"
TODO="$2"
SET="$3"
DEF="$4"
VAR="$5"
MESSAGE="$6"
eval VARD=\$${VAR}

if [ -n "$VARD" -a -e /proc/sys/net/$WHAT ]; then
	if [ "$TODO" = "start" ]; then
	        is_no "$VARD" && [ "$SET" = "1" ] && SET="$(($SET - 1))"
		is_yes "$VARD" && [ "$SET" = "0" ] && SET="$(($SET + 1))"
		if [ -n "$MESSAGE" ]; then
			show "`nls "Setting %s to %s" "$MESSAGE" "$SET"`"; busy
			if (echo "$SET" > /proc/sys/net/$WHAT) 2> /dev/null; then
				deltext; ok
			else
				deltext; fail
			fi
		else
			echo "$SET" > /proc/sys/net/$WHAT
		fi
	elif [ "$TODO" = "stop" ]; then
		if [ -n "$MESSAGE" ]; then
			show "`nls "Setting %s to %s" "$MESSAGE" "$DEF"`"; busy
			if (echo "$DEF" > /proc/sys/net/$WHAT) 2> /dev/null; then
				deltext; ok
			else
				deltext; fail
			fi
		fi
	fi
fi
return 0
}

ipv4_dynamic_ip_patch()
{
if [ "$IPV4_DYNAMIC_IP_PATCH" != "default" -a -n "$IPV4_DYNAMIC_IP_PATCH" ] ||
   [ ! -e /proc/sys/net/ipv4/ip_dynaddr ]; then
	case "$IPV4_DYNAMIC_IP_PATCH_VALUE" in
		[1-9])	;;
		*)	IPV4_DYNAMIC_IP_PATCH_VALUE=7 ;;
	esac

	if is_yes "$IPV4_DYNAMIC_IP_PATCH" && [ "$1" = "on" ]; then
		show "Enabling dynamic IP patch"
		busy
		if echo $IPV4_DYNAMIC_IP_PATCH_VALUE > /proc/sys/net/ipv4/ip_dynaddr; then
			deltext
			ok
		else
			deltext
			fail
		fi
	else
		show "Disabling dynamic IP patch"
		busy
		if echo 0 > /proc/sys/net/ipv4/ip_dynaddr; then
			deltext
			ok
		else
			deltext
			fail
		fi
	fi
fi
}

ipv4_local_port_range()
{
if [ "$IPV4_LOCAL_PORT_RANGE" != "default" -a -n "$IPV4_LOCAL_PORT_RANGE" ] || \
   [ ! -e /proc/sys/net/ipv4/ip_local_port_range ]; then
	if is_yes "$IPV4_LOCAL_PORT_RANGE" && [ "$1" = "on" ]; then
		show "Setting local port range"; busy
		if echo "$IPV4_LOCAL_PORT_RANGE" > /proc/sys/net/ipv4/ip_local_port_range; then
			deltext
			ok
		else
			deltext
			fail
		fi
	else
		show "Setting default local port range"; busy
		if echo "1024 4999" > /proc/sys/net/ipv4/ip_local_port_range; then
			deltext
			ok
		else
			deltext
			fail
		fi
	fi
fi
}

ipv4_anti_spoofing()
{
if [ "$IPV4_ANTI_SPOOFING" != "default" -a -n "$IPV4_ANTI_SPOOFING" ] || \
   [ ! -e /proc/sys/net/ipv4/conf/all/rp_filter ]; then
	if is_yes "$IPV4_ANTI_SPOOFING" && [ "$1" = "on" ]; then
		show "Setting up IP spoofing protection"; busy
		if (for f in /proc/sys/net/ipv4/conf/*/rp_filter; do echo 1 > $f; done); then
			deltext
			ok
		else
			deltext
			fail
		fi
	else
		show "Setting down IP spoofing protection"; busy
		if (for f in /proc/sys/net/ipv4/conf/*/rp_filter; do echo 0 > $f; done); then
			deltext
			ok
		else
			deltext
			fail
		fi
	fi
fi
}

#
# following function sets up routes not associated to any device
# eg. unreachable or blackhole routes
# (c) 1999 Jacek Konieczny <jajcus@pld.org.pl>
#
setup_routes(){

	if [ -f /etc/sysconfig/static-routes ]; then
		if [ "$1" = "on" -o "$1" = "yes" ] ; then
			egrep "^(none)|(any)[[:blank:]]" /etc/sysconfig/static-routes | while read device args; do
				/sbin/ip route add $args
			done
		else
			egrep "^(none)|(any)[[:blank:]]" /etc/sysconfig/static-routes | while read device args; do
				/sbin/ip route del $args 2>/dev/null
			done
		fi
	fi
}

# Add ONLY IPv4 address (IPv6 address is added automaticly)
set_up_loopback()
{
ip link set dev lo up arp on
ip addr add 127.0.0.1/8 dev lo
}

set_down_loopback()
{
ip addr flush dev lo 2> /dev/null
ip link set dev lo down
}

static_arp()
{
if is_yes "$STATIC_ARP"; then
	if [ -r /etc/ethers -a -x /sbin/arp ]; then
		/sbin/arp -f /etc/ethers
	fi
fi
}

modprobe_net()
{
if is_yes "$IPV6_NETWORKING" && [ "`ls -R /lib/modules/\`uname -r\`/ | grep ipv6.o`" != "" ]; then
	modprobe -s -k net-pf-10
	if is_yes "$IPV6_TUNNELCONFIG" && [ "`ls -R /lib/modules/\`uname -r\`/ | grep ipip.o`" != "" ]; then
		modprobe -s -k ipip
	fi
fi
}

#
# folowing function calculates network prefix from given network mask
# (c) 1999 Grzegorz Stanislawski <stangrze@open.net.pl>
#
calcprefix() {
local OISF len olen bad prefix
OISF=$IFS
IFS="."
prefix=0
olen=8
bad=0

for i in $1; do
	len=0
	case $i in
	255)	len=8 ;;
	254)	len=7 ;;
	252)	len=6 ;;
	248)	len=5 ;;
	240)	len=4 ;;
	224)	len=3 ;;
	192)	len=2 ;;
	128)	len=1 ;;
	0)	len=0 ;;
	*)	len=300 ;;
	esac

	if [ "$len" -gt "$olen" ] ; then bad=1; fi
	prefix=$(($prefix + $len))
	olen=$len
done

IFS=$OIFS
if [ "$bad" = "0" ]; then
	echo "$prefix"
else
	echo "32"
fi
return
}

#
# folowing function calculates network mask from given prefix
# (c) 1999 Grzegorz Stanislawski <stangrze@open.net.pl>
#
calcnetmask() {
local prefix a MASK
MASK=""
if [ "`echo "${1}" | grep "^[0-9]"`" = "" ]; then
	prefix=32
else
	typeset -i prefix=$1
fi
for i in 1 2 3 4; do
	case $prefix in
	7) a=254 ;;
	6) a=252 ;;
	5) a=248 ;;
	4) a=240 ;;
	3) a=224 ;;
	2) a=192 ;;
	1) a=128 ;;
	*)
		if [ $prefix -ge 8 ]; then a=255; fi 
		if [ $prefix -le 0 ]; then a=0; fi
		;;
	esac

	prefix="$(( $prefix - 8))"
	if [ -z "$MASK" ]; then
		MASK=$a
	else
		MASK=$MASK.$a
	fi
done

echo $MASK
return
}

# Retrievies PPPD PID and real interface name from /var/run/ppp-*.pid
get_ppp_device_and_pid () {
	
	if [ -f "/var/run/ppp-$DEVICE.pid" ] ; then
		eval `{
		         read PID ; echo "PID='$PID'" 
			 read REALDEVICE ; echo "REALDEVICE=$REALDEVICE"
		      } < "/var/run/ppp-$DEVICE.pid"`
	fi
	if [ -z "$REALDEVICE" ] ; then
		REALDEVICE=$DEVICE
	fi
}

