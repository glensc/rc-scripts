#!/bin/sh
#
# /etc/rc.d/rc.sysinit - run once at boot time
# $Id: rc.sysinit,v 1.71 2000/08/04 13:58:52 marcus Exp $
#
# Taken in part from Miquel van Smoorenburg's bcheckrc.
# Changes:      Arkadiusz Mi¶kiewicz <misiek@pld.org.pl>
#

# Set the path
PATH=/bin:/sbin:/usr/bin:/usr/sbin
export PATH

# NLS
if [ -f /etc/sysconfig/i18n ]; then
	. /etc/sysconfig/i18n
	[ -n "$LANG" ] && export LANG || unset LANG
	[ -n "$LC_CTYPE" ] && export LC_CTYPE || unset LC_CTYPE
	[ -n "$LC_COLLATE" ] && export LC_COLLATE || unset LC_COLLATE
	[ -n "$LC_MESSAGES" ] && export LC_MESSAGES || unset LC_MESSAGES
	[ -n "$LC_NUMERIC" ] && export LC_NUMERIC || unset LC_NUMERIC
	[ -n "$LC_MONETARY" ] && export LC_MONETARY || unset LC_MONETARY
	[ -n "$LC_TIME" ] && export LC_TIME || unset LC_TIME
	[ -n "$LC_ALL" ] && export LC_ALL || unset LC_ALL
	[ -n "$LANGUAGE" ] && export LANGUAGE || unset LANGUAGE
	[ -n "$LINGUAS" ] && export LINGUAS || unset LINGUAS
fi

# Read functions
. /etc/rc.d/init.d/functions

# Read network config data.
if [ -f /etc/sysconfig/network ]; then
	. /etc/sysconfig/network
else
	NETWORKING=no
	HOSTNAME=localhost
fi

# Read system config data.
if [ -f /etc/sysconfig/system ]; then
	. /etc/sysconfig/system
else
	RUN_SULOGIN_ON_ERR=yes
	RUN_ISAPNP=yes
	PANIC_REBOOT_TIME=0
	DELAY_LOGIN=yes
	CLEAN_TMP=no
	CONSOLE_LOGLEVEL=1
	LOAD_SOUND=yes
	SET_SLINKS=yes
	RUN_LDCONFIG=yes
fi

# Print welcome message
echo -e "\t\t\t`termput setaf 6`Powered by `termput setaf 2`PLD GNU/Linux`termput setaf 7`"
if is_yes "$PROMPT"; then
	echo -en "\t\t`nls "Press"` '`termput setaf 1`I`termput setaf 7`' `nls "to enter interactive startup."`"
	echo
	sleep 1
fi

# we need /proc mounted before everything
mount -n -o gid=17 -t proc /proc /proc

# /dev must be also mounted before everything but only if we want use them ;-)
if is_yes "$MOUNT_DEVFS"; then
    run_cmd "Mounting Device Filesystem" mount -n -t devfs /dev /dev
fi

# set up devfsd
if is_yes "$RUN_DEVFSD"; then
    if [ -x /sbin/devfsd -a -f /etc/devfsd.conf ]; then
	    run_cmd "Starting Device Filesystem Daemon" /sbin/devfsd /dev
    fi
fi

# Set console loglevel
/bin/dmesg -n $CONSOLE_LOGLEVEL

# Turn off sysrq
if [ -f /proc/sys/kernel/sysrq ] && is_no "$MAGIC_SYSRQ"; then
        echo "0" > /proc/sys/kernel/sysrq
	run_cmd "Turning off Magic SysRq key" /bin/true
fi

# Turn off Stop-A
if [ -f /proc/sys/kernel/stop-a ] && is_no "$STOP_A"; then
	echo "0" > /proc/sys/kernel/stop-a
	run_cmd "Turning off Stop-A/Break-A" /bin/true
fi

# Set the system clock.
ARC=0
SRM=0
UTC=0

if [ -f /etc/sysconfig/clock ]; then
   . /etc/sysconfig/clock

   # convert old style clock config to new values
   if [ "${CLOCKMODE}" = "GMT" ]; then
      UTC=true
   elif [ "${CLOCKMODE}" = "ARC" ]; then
      ARC=true
   fi
fi

if grep "system serial" /proc/cpuinfo | grep -q MILO ; then
   ARC=true
fi

CLOCKDEF=""
CLOCKFLAGS="--hctosys"

case "$UTC" in
   yes|true)
    CLOCKFLAGS="$CLOCKFLAGS -u";
    CLOCKDEF="$CLOCKDEF (utc)";
  ;;
esac

case "$ARC" in
     yes|true)
        CLOCKFLAGS="$CLOCKFLAGS -A";
        CLOCKDEF="$CLOCKDEF (arc)";
     ;;
esac
case "$SRM" in
     yes|true)
        CLOCKFLAGS="$CLOCKFLAGS -S";
        CLOCKDEF="$CLOCKDEF (srm)";
     ;;
esac

# Check if timezone definition is available
if [ -e /etc/localtime ] ; then
	if run_cmd "Setting clock$CLOCKDEF" /sbin/hwclock $CLOCKFLAGS; then
		show "Today's date: `LC_CTYPE=C date`"; ok
	fi
else
	TIME_SETUP_DELAYED=yes
fi

# Start up swapping.
run_cmd "`nls "Activating swap partitions"`" swapon -a

# Set the hostname.
run_cmd "`nls "Host:"` ${HOSTNAME}" hostname ${HOSTNAME}

# Set the NIS domain name
if [ -n "$NISDOMAIN" ]; then
	run_cmd "`nls "NIS Domain:"` ${NISDOMAIN}" domainname $NISDOMAIN
else
	domainname ""
fi

# Setup hdparm thingy (if exists)
[ -x /etc/rc.d/rc.hdparm ] && /etc/rc.d/rc.hdparm

if [ -f /fsckoptions ]; then
	fsckoptions=`cat /fsckoptions`
else
	fsckoptions=''
fi

if [ -f /forcefsck ]; then
        fsckoptions="-f $fsckoptions"
fi

_RUN_QUOTACHECK=0
if awk '{ if ($2 ~ /^\/$/ && ( $3 ~ /^(nfs|romfs)$/ || $6 ~ /^0$/ ) ) exit 1 ; else exit 0}' /etc/fstab; then

    if [ ! -f /fastboot  ]; then
    	    show "Checking root filesystems."; started
	    initlog -c "fsck -C -T -a $fsckoptions /"

	    rc=$?

	    # A return of 2 or higher means there were serious problems.
	    if [ $rc -gt 1 ]; then
		    # don't use '\n' in nls macro !
		    echo "\n\n"
		    nls "*** An error occurred during the file system check."
		    nls "*** Dropping you to a shell; the system will reboot"
		    nls "*** when you leave the shell."
		    echo

		    PS1="`nls "(Repair filesystem)# "`"; export PS1
		    if is_yes "$RUN_SULOGIN_ON_ERR"; then
			    sulogin
		    else
			    /bin/sh
		    fi

		    run_cmd "Unmounting file systems" umount -a
		    mount -n -o remount,ro /
		    run_cmd "Automatic reboot in progress." reboot
	    elif [ "$rc" = "1" ]; then
		    _RUN_QUOTACHECK=1
	    fi
    fi

fi

# check for arguments 
if grep -i nopnp /proc/cmdline >/dev/null ; then
	PNP=
else
	PNP=yes
fi

# set up pnp 
if [ -x /sbin/isapnp -a -f /etc/isapnp/isapnp.conf ]; then
	if [ -n "$PNP" ] && is_yes "$RUN_ISAPNP"; then
		run_cmd "Setting up ISA PNP devices" /sbin/isapnp /etc/isapnp/isapnp.conf
	fi
fi


# Remount the root filesystem read-write.
run_cmd "Remounting root filesystem in rw mode" mount -n -o remount,rw /

# Update quotas if fsck was run on /.
if [ X"$_RUN_QUOTACHECK" = "X1" -a -x /sbin/quotacheck ]; then
        run_cmd "Checking root filesystem quotas" /sbin/quotacheck -v /
fi

# /etc/nologin when starting system
[ -f /etc/nologin.boot ] && rm -f /etc/nologin /etc/nologin.boot

if is_yes "$DELAY_LOGIN" && [ ! -f /etc/nologin ]; then
	show "Enabling Delay Login"; busy
	echo > /etc/nologin
	nls "System bootup in progress  - please wait" >> /etc/nologin
	echo >> /etc/nologin
	chmod 644 /etc/nologin
	cp -fp /etc/nologin /etc/nologin.boot
	ok
fi

echo ${HOSTNAME} > /etc/HOSTNAME

# Clear mtab
>/etc/mtab

# Enter root and /proc into mtab.
mount -f /
mount -f /proc

if [ ! -f /proc/modules ]; then
	USEMODULES=
elif ! grep -i nomodules /proc/cmdline >/dev/null ; then
	USEMODULES=y
else
	USEMODULES=
fi

# Kernel dependent links
rm -f /lib/modules/preferred
rm -f /lib/modules/default
if [ -x /sbin/depmod -a -n "$USEMODULES" ]; then
	if is_yes "$SET_SLINKS"; then
	# Get ready for kmod if module support in the kernel
		if [ -z `uname -r | grep "-"` ]; then
		# we're using a new kernel, no preferred needed
			mver=`uname -r`
		else
			ktag="`cat /proc/version`"
			mtag=grep -l "$ktag" /lib/modules/*/.rhkmvtag 2> /dev/null
			if [ -n "$mtag" ]; then
				mver=echo $mtag | sed -e 's,/lib/modules/,,' -e 's, \
					/.rhkmvtag,,' -e 's,[       ].*$,,'
			fi
			if [ -n "$mver" ]; then
				ln -sf /lib/modules/$mver /lib/modules/default
			fi
		fi
	fi
	[ -n "$mver" -a -f "/boot/module-info-$mver" ] && \
		ln -sf /boot/module-info-$mver /boot/module-info
	[ -n "$mver" -a -f "/boot/System.map-$mver" ] && \
		ln -sf /boot/System.map-$mver /boot/System.map

	# Run depmod if:
	# a) user requested or RUN_DEPMOD="";
	# b) modules.dep is missing
	# c) modules.dep is older than /etc/modules.conf or /lib/modules/$mver
	if ! is_no "$RUN_DEPMOD" || [ -z "$RUN_DEPMOD" ]; then
		if [ "$RUN_DEPMOD" = "ifmissing" -a ! -r /lib/modules/$mver/modules.dep ] ||\
		is_yes "$RUN_DEPMOD" || [ -z "$RUN_DEPMOD" ] ||\
		[ /lib/modules/$mver/modules.dep -ot /etc/modules.conf ] ||\
		[ /lib/modules/$mver/modules.dep -ot /lib/modules/$mver ]
		then
			run_cmd "Finding module dependencies" depmod -a
		fi
	fi
fi

# load sound modules
if [ -n "$USEMODULES" ] && is_yes "$LOAD_SOUND"; then
	if grep -s -q "^alias sound-slot-0" /etc/modules.conf ; then
		run_cmd "Loading sound module" modprobe -s sound-slot-0
	fi
	if grep -s -q "^alias synth0" /etc/modules.conf ; then
		run_cmd "Loading synthesiser module" modprobe -s synth0
	fi
fi

if [ -f /proc/sys/kernel/modprobe ]; then
	# /proc/sys/kernel/modprobe indicates built-in kmod instead
	echo "/sbin/modprobe" > /proc/sys/kernel/modprobe
fi

# Load modules
if [ -f /etc/rc.d/rc.modules ]; then
	/etc/rc.d/rc.modules
fi

# Add raid devices
if [ -f /proc/mdstat -a -f /etc/raidtab ]; then
	show "Starting up RAID devices."; started

	rc=0
	
	for i in `grep "raiddev" /etc/raidtab | awk '{print $2}'`
	do
		RAIDDEV=`basename $i`
		RAIDSTAT=`grep "^$RAIDDEV : active" /proc/mdstat`
		if [ -z "$RAIDSTAT" ]; then
			# Try raidstart first...if that fails then
			# fall back to raid0run.
			RESULT=1
			if [ -x /sbin/raidstart ]; then
				/sbin/raidstart $i
				RESULT=$?
			fi
			if [ $RESULT -gt 0 -a -x /sbin/raid0run ]; then
				/sbin/raid0run $i
			fi
		fi
	done

	# A non-zero return means there were problems.
	if [ $rc -gt 0 ]; then
		show "Starting up RAID devices."; fail
		echo "\n\n"
		nls "*** An error occurred during the RAID startup"
		nls "*** Dropping you to a shell; the system will reboot"
		nls "*** when you leave the shell."
		echo

		PS1="`nls "(RAID Repair)# "`"; export PS1
		if is_yes "$RUN_SULOGIN_ON_ERR"; then
			sulogin
		else
			/bin/sh
		fi

		run_cmd "Unmounting file systems" umount -a
		run_cmd "Remounting root filesystem in ro mode" mount -n -o remount,ro /
		run_cmd "Automatic reboot in progress" reboot
	fi
	show "Starting up RAID devices."; ok
fi

# Check filesystems
if [ ! -f /fastboot ]; then
	show "Checking filesystems."; started
	initlog -c "fsck -C -T -R -A -a $fsckoptions"

	rc=$?

	# A return of 2 or higher means there were serious problems.
	if [ $rc -gt 1 ]; then
		echo "\n\n"
		nls "*** An error occurred during the file system check."
		nls "*** Dropping you to a shell; the system will reboot"
		nls "*** when you leave the shell."
		echo

		PS1="`nls "(Repair filesystem)# "`"; export PS1
		if is_yes "$RUN_SULOGIN_ON_ERR"; then
			sulogin
		else
			/bin/sh
		fi

		run_cmd "Unmounting file systems" umount -a
		run_cmd "Remounting root filesystem in ro mode" mount -n -o remount,ro /
		run_cmd "Automatic reboot in progress." reboot
	elif [ "$rc" = "1" -a -x /sbin/quotacheck ]; then
		run_cmd "Checking filesystem quotas" /sbin/quotacheck -v -R -a
	fi
fi

# Mount all other filesystems (except for NFS and /proc, which is already
# mounted). Contrary to standard usage,
# filesystems are NOT unmounted in single user mode.
run_cmd "Mounting local filesystems." mount -a -t nonfs,smbfs,ncpfs,proc

# Set the clock if timezone definition wasn't available (eg. /usr not mounted)
if is_yes "$TIME_SETUP_DELAYED"; then
	if run_cmd "Setting clock$CLOCKDEF" /sbin/hwclock $CLOCKFLAGS; then
		show "Today's date: `LC_CTYPE=C date`"; ok
	fi
fi

if [ -x /sbin/quotaon ]; then
	run_cmd "Turning on quotas for local filesystems" /sbin/quotaon -a
fi

# Initialize the serial ports.
if [ -f /etc/rc.d/rc.serial ]; then
	. /etc/rc.d/rc.serial
fi

if [ -f /proc/sys/kernel/panic -a "$PANIC_REBOOT_TIME" -gt "0" ]; then
	show "`nls "Setting %s seconds for kernel reboot after panic." "$PANIC_REBOOT_TIME"`"; busy
	if (echo $PANIC_REBOOT_TIME > /proc/sys/kernel/panic); then ok; else fail; fi
fi

# Clean out /etc & /var/{run/*,log/{b,w}tmpx}}.
rm -f /etc/mtab~ /fastboot /fsckoptions /forcefsck

{
# Clean up utmp/wtmp
rm -f /var/run/utmp?
if ! is_no "$NEED_XFILES" ; then
	:>/var/run/utmpx
	touch /var/log/wtmpx
	chown root.utmp /var/run/utmpx /var/log/wtmpx
	chmod 0664 /var/run/utmpx /var/log/wtmpx
else
	:>/var/run/utmp
	touch /var/log/wtmp
	chown root.utmp /var/run/utmp /var/log/wtmp
	chmod 0664 /var/run/utmp /var/log/wtmp
fi

# Clean /tmp
if is_yes "$CLEAN_TMP"; then
	rm -rf /tmp/*
fi

# Delete UUCP lock files.
rm -f /var/lock/LCK*

# Delete stale subsystem files.
rm -f /var/lock/subsys/*

# Delete stale pam_console locks.
rm -f /var/lock/console/*
rm -f /var/lock/console.lock

# Delete stale pid files
rm -f /var/run/*.pid
rm -f /var/spool/postoffice/.pid.*

# Delete X locks
rm -f /tmp/.X*-lock

# Delete Postgres sockets
rm -f /tmp/.s.PGSQL.*

# Right, now turn on swap in case we swap to files.
swapon -a >/dev/null 2>&1
run_cmd "Enabling swap space" /bin/true

# If a SCSI tape has been detected, load the st module unconditionally
# since many SCSI tapes don't deal well with st being loaded and unloaded
if [ -f /proc/scsi/scsi ] && cat /proc/scsi/scsi | grep -q 'Type:   Sequential-Access' 2>/dev/null ; then
	if cat /proc/devices | grep -qv ' 9 st' ; then
		if [ -n "$USEMODULES" ] ; then
			# Try to load the module.  If it fails, ignore it...
			insmod -p st >/dev/null 2>&1 && modprobe -s st >/dev/null 2>&1
		fi
	fi
fi

# there could be a new kernel version.  remove old psdevtab database
rm -f /etc/psdevtab

# If needed increase number of available system files
# There are two versions of each setting, because file names
# changed between Linux 2.0 and 2.2
if [ -n "$VFS_FILE_MAX" ] ; then
	if [ -f /proc/sys/kernel/file-max -a "$VFS_FILE_MAX" -gt 0 ]; then
        	echo $VFS_FILE_MAX >/proc/sys/kernel/file-max
	fi
	if [ -f /proc/sys/fs/file-max -a "$VFS_FILE_MAX" -gt 0 ]; then
        	echo $VFS_FILE_MAX >/proc/sys/fs/file-max
	fi
fi
if [ -n "$VFS_INODE_MAX" ] ; then
	if [ -f /proc/sys/kernel/inode-max -a "$VFS_INODE_MAX" -gt 0 ]; then
        	echo $VFS_INODE_MAX >/proc/sys/kernel/inode-max
	fi
	if [ -f /proc/sys/fs/inode-max -a "$VFS_INODE_MAX" -gt 0 ]; then
        	echo $VFS_INODE_MAX >/proc/sys/fs/inode-max
	fi
fi


# Now that we have all of our basic modules loaded and the kernel going,
# let's dump the syslog ring somewhere so we can find it later
dmesg > /var/log/dmesg
chmod 640 /var/log/dmesg

# Now that we have all of our basic modules loaded and the kernel going,
# let's dump the syslog ring somewhere so we can find it later
kill -TERM `/sbin/pidof getkey` >/dev/null 2>&1
} &
if is_yes "$PROMPT"; then
   /sbin/getkey i && touch /var/run/confirm
fi
wait
