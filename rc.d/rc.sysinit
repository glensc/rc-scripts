#!/bin/sh
#
# /etc/rc.d/rc.sysinit - run once at boot time
# $Id: rc.sysinit,v 1.88 2001/10/30 09:02:58 gotar Exp $
#
# Taken in part from Miquel van Smoorenburg's bcheckrc.
# Changes:	Arkadiusz Mi¶kiewicz <misiek@pld.org.pl>
#

# Set the path
PATH=/bin:/sbin:/usr/bin:/usr/sbin
export PATH

# NLS
if [ -r /etc/sysconfig/i18n ]; then
	. /etc/sysconfig/i18n
	[ -n "$LANG" ] && export LANG || unset LANG
	[ -n "$LC_CTYPE" ] && export LC_CTYPE || unset LC_CTYPE
	[ -n "$LC_COLLATE" ] && export LC_COLLATE || unset LC_COLLATE
	[ -n "$LC_MESSAGES" ] && export LC_MESSAGES || unset LC_MESSAGES
	[ -n "$LC_NUMERIC" ] && export LC_NUMERIC || unset LC_NUMERIC
	[ -n "$LC_MONETARY" ] && export LC_MONETARY || unset LC_MONETARY
	[ -n "$LC_TIME" ] && export LC_TIME || unset LC_TIME
	[ -n "$LC_ALL" ] && export LC_ALL || unset LC_ALL
	[ -n "$LANGUAGE" ] && export LANGUAGE || unset LANGUAGE
	[ -n "$LINGUAS" ] && export LINGUAS || unset LINGUAS
fi

# Read functions
. /etc/rc.d/init.d/functions

# Read network config data
if [ -r /etc/sysconfig/network ]; then
	. /etc/sysconfig/network
else
	NETWORKING=no
	HOSTNAME=localhost
fi

# Read system config data
if [ -r /etc/sysconfig/system ]; then
	. /etc/sysconfig/system
else
	RUN_SULOGIN_ON_ERR=yes
	RUN_ISAPNP=yes
	PANIC_REBOOT_TIME=0
	DELAY_LOGIN=yes
	CLEAN_TMP=no
	CONSOLE_LOGLEVEL=1
	LOAD_SOUND=yes
	SET_SLINKS=yes
	RUN_LDCONFIG=yes
fi

# Print welcome message
nls "\t\t\t%sPowered by %sPLD GNU/Linux%s" "$(termput setaf 6)" "$(termput setaf 2)" "$(termput setaf 7)"
if is_yes "$PROMPT"; then
	nls -n "\t\t  Press %sI%s to enter interactive startup." "$(termput setaf 1)" "$(termput setaf 7)"
	echo
	sleep 1
fi

# We need /proc mounted before everything
mount -n -o gid=17 -t proc /proc /proc

# Set console loglevel
/bin/dmesg -n $CONSOLE_LOGLEVEL

# /dev must be also mounted before everything but only if we want use them ;-)
if is_yes "$MOUNT_DEVFS"; then
	run_cmd "Mounting Device Filesystem" mount -n -t devfs /dev /dev
fi

# set up devfsd
if is_yes "$RUN_DEVFSD"; then
	if [ -x /sbin/devfsd -a -f /etc/devfsd.conf ]; then
		run_cmd "Starting Device Filesystem Daemon" /sbin/devfsd /dev
	fi
fi

# Configure Linux kernel
run_cmd "Configuring kernel parameters" /sbin/sysctl -p /etc/sysctl.conf

# Set the system clock.
ARC=0
SRM=0
UTC=0

if [ -f /etc/sysconfig/clock ]; then
	. /etc/sysconfig/clock

	# convert old style clock config to new values
	if [ "${CLOCKMODE}" = "GMT" ]; then
		UTC=true
	elif [ "${CLOCKMODE}" = "ARC" ]; then
		ARC=true
	fi
fi

if grep "system serial" /proc/cpuinfo | grep -q MILO ; then
	ARC=true
fi

CLOCKDEF=""
CLOCKFLAGS="--hctosys"

if is_yes "$UTC" ; then
	CLOCKFLAGS="$CLOCKFLAGS --utc"
	CLOCKDEF="$CLOCKDEF (utc)"
else
	CLOCKFLAGS="$CLOCKFLAGS --localtime"
	CLOCKDEF="$CLOCKDEF (local)"
fi

if is_yes "$ARC" ; then
	CLOCKFLAGS="$CLOCKFLAGS -A"
	CLOCKDEF="$CLOCKDEF (arc)"
fi

if is_yes "$SRM" ; then
	CLOCKFLAGS="$CLOCKFLAGS -S"
	CLOCKDEF="$CLOCKDEF (srm)"
fi

# Check if timezone definition is available
if [ -e /etc/localtime ] ; then
	if run_cmd "$(nls 'Setting clock')$CLOCKDEF" /sbin/hwclock $CLOCKFLAGS; then
		show "$(nls 'Today`s date:') $(LC_CTYPE=C date)"; ok
	fi
else
	TIME_SETUP_DELAYED=yes
fi

# Start up swapping
run_cmd "Activating swap partitions" swapon -a

# Set the hostname
run_cmd "$(nls 'Host:') ${HOSTNAME}" hostname ${HOSTNAME}

# Set the NIS domain name
if [ -n "$NISDOMAIN" ]; then
	run_cmd "$(nls 'NIS Domain:') ${NISDOMAIN}" domainname $NISDOMAIN
else
	domainname ""
fi

# Initialize USB controller and HID devices
usb=0
if ! grep -iq "nousb" /proc/cmdline 2>/dev/null && ! grep -q "usb" /proc/devices 2>/dev/null ; then
	aliases=$(/sbin/modprobe -c | egrep -s "^alias[[:space:]]+usb-controller" | awk '{ print $3 }')
	if [ -n "$aliases" -a "$aliases" != "off" ] ; then
		/sbin/modprobe -k usbcore
		run_cmd "Mounting USB filesystem" mount -t usbdevfs usbdevfs /proc/bus/usb
		for alias in $aliases ; do 
			run_cmd "$(nls 'Initializing USB controller') ($alias)" /sbin/modprobe $alias
		done
		[ $? -eq 0 -a -n "$aliases" ] && usb=1
	fi
fi

if ! grep -iq "nousb" /proc/cmdline 2>/dev/null && grep -q "usb" /proc/devices 2>/dev/null ; then
	usb=1
fi

needusbstorage=
if [ $usb = "1" ]; then
	sleep 5
	mouseoutput=$(cat /proc/bus/usb/devices 2>/dev/null|grep -E "^I.*Cls=03.*Prot=02")
	kbdoutput=$(cat /proc/bus/usb/devices 2>/dev/null|grep -E "^I.*Cls=03.*Prot=01")
	needusbstorage=$(cat /proc/bus/usb/devices 2>/dev/null|grep -e "^I.*Cls=08")
	if [ -n "$kbdoutput" ] || [ -n "$mouseoutput" ]; then
		run_cmd "Initializing USB HID interface" modprobe hid 2> /dev/null
	fi
	if [ -n "$kbdoutput" ]; then
		run_cmd "Initializing USB keyboard" modprobe keybdev
	fi
	if [ -n "$mouseoutput" ]; then
		run_cmd "Initializing USB mouse" modprobe mousedev
	fi
fi

# Setup hdparm thing (if exists and is needed)
if ! grep -iq nohdparm /proc/cmdline; then
	[ -x /etc/rc.d/rc.hdparm ] && /etc/rc.d/rc.hdparm
fi

if [ -f /fastboot ] || grep -iq "fastboot" /proc/cmdline 2> /dev/null ; then
	fastboot=yes
else
	fastboot=
fi

if [ -f /fsckoptions ]; then
	fsckoptions=$(cat /fsckoptions)
else
	fsckoptions=''
fi

if [ -f /forcefsck ]; then
        fsckoptions="-f $fsckoptions"
fi

_RUN_QUOTACHECK=0
_ROOTFS_TYPE=$(grep " / " /proc/mounts | awk '{ print $3 }')

if [ -z "$fastboot" -a "$_ROOTFS_TYPE" != "nfs" -a "$_ROOTFS_TYPE" != "romfs" ]; then 
	show "Checking root filesystem"; started
	initlog -c "fsck -C -T -a $fsckoptions /"

	rc=$?

	# A return of 2 or higher means there were serious problems.
	if [ $rc -gt 1 ]; then
		# don't use '\n' in nls macro !
		echo
		echo
		nls "*** An error occurred during the file system check."
		nls "*** Dropping you to a shell; the system will reboot"
		nls "*** when you leave the shell."
		echo

		PS1="$(nls '(Repair filesystem)# ')"; export PS1
		if is_yes "$RUN_SULOGIN_ON_ERR"; then
			sulogin
		else
			/bin/sh
		fi

		run_cmd "Unmounting file systems" umount -a
		mount -n -o remount,ro /
		run_cmd "Automatic reboot in progress" reboot
	elif [ "$rc" = "1" ]; then
		_RUN_QUOTACHECK=1
	fi
fi

# Check for arguments 
if grep -iq nopnp /proc/cmdline; then
	PNP=
else
	PNP=yes
fi

# set up pnp and kernel pnp
if [ -n "$PNP" ]; then
    if [ -x /sbin/isapnp -a -f /etc/isapnp/isapnp.conf ] && is_yes "$RUN_ISAPNP"; then
	run_cmd "Setting up ISA PNP devices (userspace pnp)" /sbin/isapnp /etc/isapnp/isapnp.conf
    fi
    if [ -e /proc/isapnp -a -f /etc/isapnp/isapnp-kernel.conf ]; then
	show "Setting up ISA PNP devices (kernelspace pnp)"; busy
	cat /etc/isapnp/isapnp-kernel.conf > /proc/isapnp && (deltext; ok) || (deltext; fail)
    fi
fi

# Remount the root filesystem read-write
run_cmd "Remounting root filesystem in rw mode" mount -n -o remount,rw /

# Clear mtab
>/etc/mtab

# Remove stale backups
rm -f /etc/mtab~ /etc/mtab~~

# Enter root, /proc and (potentially) /proc/bus/usb and devfs into mtab.
mount -f /
mount -f /proc
[ -f /proc/bus/usb/devices ] && mount -f -t usbdevfs usbdevfs /proc/bus/usb
if is_yes "$MOUNT_DEVFS"; then
	mount -f -t devfs devfs /dev
fi

# Update quotas if fsck was run on /
if [ "$_RUN_QUOTACHECK" = "1" -a -x /sbin/quotacheck ]; then
	run_cmd "Checking root filesystem quotas" /sbin/quotacheck -vug /
fi

# Remove /etc/nologin when starting system
[ -f /etc/nologin.boot ] && rm -f /etc/nologin /etc/nologin.boot

if is_yes "$DELAY_LOGIN" && [ ! -f /etc/nologin ]; then
	show "Enabling Delay Login"; busy
	echo > /etc/nologin
	nls "System bootup in progress - please wait" >> /etc/nologin
	echo >> /etc/nologin
	chmod 644 /etc/nologin
	cp -fp /etc/nologin /etc/nologin.boot
	ok
fi

# The root filesystem is now read-write, so we can now log via
# syslog() directly...
if [ -n "$IN_INITLOG" ]; then
	IN_INITLOG=""
fi

if [ ! -f /proc/modules ]; then
	USEMODULES=
elif ! grep -iq nomodules /proc/cmdline; then
	USEMODULES=y
else
	USEMODULES=
fi

# Adjust symlinks as necessary in /boot to keep system services from
# spewing messages about mismatched System maps and so on.
if is_yes "$SET_SLINKS"; then
	if [ -L /boot/System.map -a -r /boot/System.map-`uname -r` ] ; then
	        ln -s -f System.map-`uname -r` /boot/System.map
	fi
	if [ ! -e /boot/System.map -a -r /boot/System.map-`uname -r` ] ; then
	        ln -s -f System.map-`uname -r` /boot/System.map
	fi
fi

# Run depmod if RUN_DEPMOD != "no" and:
# a) user requested or RUN_DEPMOD="";
# b) modules.dep is missing
# c) modules.dep is older than /etc/modules.conf or /lib/modules/$mver
if ! is_no "$RUN_DEPMOD" && [ -n "$USEMODULES" ]; then
	if is_yes "$RUN_DEPMOD" || [ -z "$RUN_DEPMOD" ] || \
		[ "$RUN_DEPMOD" = "ifmissing" -a ! -r /lib/modules/$mver/modules.dep ] ||\
		[ /lib/modules/$mver/modules.dep -ot /etc/modules.conf ] ||\
		[ /lib/modules/$mver/modules.dep -ot /lib/modules/$mver ]; then
		run_cmd "Finding module dependencies" depmod -a
	fi
fi

# Load sound modules iff they need persistent DMA buffers
if grep -q "options sound dmabuf=1" /etc/modules.conf 2>/dev/null ; then
	RETURN=0
	alias=$(/sbin/modprobe -c | egrep -s "^alias[[:space:]]+sound[[:space:]]+" | awk '{ print $3 }')
	if [ -n "$alias" -a "$alias" != "off" ] ; then
		run_cmd "$(nls 'Loading sound module') ($alias)" modprobe -s $alias
		RETURN=$?
	fi
	alias=$(/sbin/modprobe -c | egrep -s "^alias[[:space:]]+sound-slot-0[[:space:]]+" | awk '{ print $3 }')
	if [ -n "$alias" -a "$alias" != "off" ] ; then
		run_cmd "$(nls 'Loading sound module') ($alias)" modprobe -s $alias
		RETURN=$?
	fi
fi

if [ -f /proc/sys/kernel/modprobe ]; then
	if [ -n "$USEMODULES" ]; then
		sysctl -w kernel.modprobe="/sbin/modprobe" >/dev/null 2>&1
		sysctl -w kernel.hotplug="/sbin/hotplug" >/dev/null 2>&1
	else
		# We used to set this to NULL, but that causes
		# 'failed to exec' messages"
		sysctl -w kernel.modprobe="/bin/true" >/dev/null 2>&1
		sysctl -w kernel.hotplug="/bin/true" >/dev/null 2>&1
	fi
fi

# Load modules
if [ -x /etc/rc.d/rc.modules ]; then
	/etc/rc.d/rc.modules
fi

# Find and activate volume groups
if [ -e /etc/lvmtab -a -x /sbin/vgscan -a -x /sbin/vgchange ]; then
	modprobe -s lvm-mod >/dev/null 2>&1
	run_cmd "Scanning for LVM volume groups" /sbin/vgscan && \
	run_cmd "Activating LVM volume groups" /sbin/vgchange -a y
fi

# Add raid devices
if [ -f /etc/raidtab ]; then

	modprobe -s md >/dev/null 2>&1
	if [ -f /proc/mdstat ]; then
	    rc=0
	
	    for i in $(grep -v "^#" /etc/raidtab | grep "raiddev" | awk '{print $2}') ; do
		RAIDDEV=$(basename $i)
		RAIDSTAT=$(grep "^$RAIDDEV : active" /proc/mdstat)
		show "Starting up RAID device %s" $RAIDDEV
		busy
		if [ -z "$RAIDSTAT" ]; then
			# Try raidstart first...if that fails then
			# fall back to raid0run and if that fails too
			# fall back to raidadd, raidrun.
			RESULT=1
			if [ -x /sbin/raidstart ]; then
				/sbin/raidstart $i
				RESULT=$?
			fi
			if [ $RESULT -gt 0 -a -x /sbin/raid0run ]; then
				/sbin/raid0run $i
				RESULT=$?
			fi
			if [ $RESULT -gt 0 -a -x /sbin/raidadd -a -x /sbin/raidrun ]; then
				/sbin/raidadd $i
				/sbin/raidrun $i
				RESULT=$?
			fi
			if [ $RESULT -gt 0 ]; then
				rc=1
				fail
			else
				ok
			fi
		else
			ok
		fi
	    done

	    # A non-zero return means there were problems
	    if [ $rc -gt 0 ]; then
		show "Starting up RAID devices."; fail
		echo
		echo
		nls "*** An error occurred during the RAID startup"
		nls "*** Dropping you to a shell; the system will reboot"
		nls "*** when you leave the shell."
		echo

		PS1="$(nls '(RAID Repair)# ')"; export PS1
		if is_yes "$RUN_SULOGIN_ON_ERR"; then
			sulogin
		else
			/bin/sh
		fi

		run_cmd "Unmounting file systems" umount -a
		run_cmd "Remounting root filesystem in ro mode" mount -n -o remount,ro /
		run_cmd "Automatic reboot in progress" reboot
	    fi
	    show "Starting up RAID devices."; ok
	fi
fi

_RUN_QUOTACHECK=0
# Check filesystems
if [ -z "$fastboot" ] && ! grep -q nofsck /proc/cmdline; then
	show "Checking filesystems"; started
	initlog -c "fsck -C -T -R -A -a $fsckoptions"

	rc=$?

	# A return of 2 or higher means there were serious problems
	if [ $rc -gt 1 ]; then
		echo
		echo
		nls "*** An error occurred during the file system check."
		nls "*** Dropping you to a shell; the system will reboot"
		nls "*** when you leave the shell."
		echo

		PS1="$(nls '(Repair filesystem)# ')"; export PS1
		if is_yes "$RUN_SULOGIN_ON_ERR"; then
			sulogin
		else
			/bin/sh
		fi

		run_cmd "Unmounting file systems" umount -a
		run_cmd "Remounting root filesystem in ro mode" mount -n -o remount,ro /
		run_cmd "Automatic reboot in progress" reboot
	elif [ "$rc" = "1" -a -x /sbin/quotacheck ]; then
		_RUN_QUOTACHECK=1
	fi
fi

# Mount all other filesystems (except for NFS and /proc, which is already
# mounted). Contrary to standard usage,
# filesystems are NOT unmounted in single user mode.

# Don'n mount devpts if devfs is already mounted
if is_yes "$MOUNT_DEVFS"; then
	run_cmd "Mounting local filesystems" mount -a -t nonfs,smbfs,ncpfs,proc,devpts
else
	run_cmd "Mounting local filesystems" mount -a -t nonfs,smbfs,ncpfs,proc
fi

# Now do some workaround - encrypted filesystems couldn't have been fsck-ed
# before mount - that's where the password is entered.
# mount is buggy - when remounting loopback filesystem, loop=XXX
# option is removed from /etc/mtab
if grep -q "encryption=" /etc/fstab; then
	show "Checking encrypted filesystems"; started
	LOOPLIST="$(
	grep "encryption=" /etc/fstab | grep -v 'noauto' | grep -w 'ro' |\
	while read FILE DIR TYPE OPTS TMP1; do
		LOOP="`cat /proc/mounts | awk '$2 == "'"$DIR"'" { print $1 }'`"
		echo "$LOOP"
	done
	grep "encryption=" /etc/fstab | grep -vw 'ro\|noauto' |\
	while read FILE DIR TYPE OPTS TMP1; do
	    	LOOP="`cat /proc/mounts | awk '$2 == "'"$DIR"'" { print $1 }'`"
		LOOPLIST="$LOOPLIST $LOOP"
	    	NEWOPTS="remount,`echo "$OPTS" | sed 's#loop\(=[^,]*\)\?#loop='"$LOOP"'#'`,ro"
		echo "$LOOP"
		mount "$DIR" -o "$NEWOPTS"
	done
	)"
	
	initlog -c "fsck -T -C -a $fsckoptions $LOOPLIST"
	rc=$?

	# A return of 2 or higher means there were serious problems.
	if [ $rc -gt 1 ]; then
		echo "\n\n"
		nls "*** An error occurred during the file system check."
		nls "*** Dropping you to a shell; the system will reboot"
		nls "*** when you leave the shell."
		echo

		PS1="`nls '(Repair filesystem)# '`"; export PS1
		if is_yes "$RUN_SULOGIN_ON_ERR"; then
			sulogin
		else
			/bin/sh
		fi

		run_cmd "Unmounting file systems" umount -a
		run_cmd "Remounting root filesystem in ro mode" mount -n -o remount,ro /
		run_cmd "Automatic reboot in progress." reboot
	elif [ "$rc" = "1" -a -x /sbin/quotacheck ]; then
		_RUN_QUOTACHECK=1
	fi
	
	show "Remounting encrypted filesystems back in rw mode"; busy
	grep "encryption=" /etc/fstab | grep -vw 'ro\|noauto' |\
	while read FILE DIR TYPE OPTS TMP1; do
	    	LOOP="`cat /proc/mounts | awk '$2 == "'"$DIR"'" { print $1 }'`"
	    	NEWOPTS="remount,`echo "$OPTS" | sed 's#loop\(=[^,]*\)\?#loop='"$LOOP"'#'`,rw"
		mount "$DIR" -o "$NEWOPTS"
	done
	ok
fi

if [ "$_RUN_QUOTACHECK" = "1" -a -x /sbin/quotacheck ]; then
	run_cmd "Checking filesystem quotas"  /sbin/quotacheck -v -u -g -R -a
fi

# Turn on quota
if [ -x /sbin/quotaon ]; then
	run_cmd "Turning on quotas for local filesystems" /sbin/quotaon -a
fi

# Turn on process accounting
if [ -x /sbin/accton ] ; then
        run_cmd "Turning on process accounting" /sbin/accton /var/log/pacct
fi

# Set the clock if timezone definition wasn't available (eg. /usr not mounted)
if is_yes "$TIME_SETUP_DELAYED"; then
	if run_cmd "$(nls 'Setting clock')$CLOCKDEF" /sbin/hwclock $CLOCKFLAGS; then
		show "$(nls 'Today`s date:') $(LC_CTYPE=C date)"; ok
	fi
fi

# Initialize the serial ports
if [ -f /etc/rc.d/rc.serial ]; then
	. /etc/rc.d/rc.serial
fi

if [ -f /proc/sys/kernel/panic -a "$PANIC_REBOOT_TIME" -gt "0" ]; then
	show 'Setting %s seconds for kernel reboot after panic.' "$PANIC_REBOOT_TIME"; busy
	if (sysctl -w kernel.panic=$PANIC_REBOOT_TIME >/dev/null 2>&1); then ok; else fail; fi
fi

# Clean up /etc.
rm -f /fastboot /fsckoptions /forcefsck /halt /poweroff

# Clean up /var
# I'd use find, but /usr may not be mounted.
for afile in /var/lock/* /var/run/*; do
	if [ -d "$afile" ]; then
		bafile=$(basename $afile)
		[ "$bafile" != "news" -a "$bafile" != "sudo" -a "$bafile" != "mon" ] && rm -f $afile/*
	else
		rm -f $afile
	fi
done

# Delete stale pid files
rm -f /var/spool/postoffice/.pid.*

{
# Clean up utmp/wtmp
rm -f /var/run/utmp?
if ! is_no "$NEED_XFILES" ; then
	:>/var/run/utmpx
	touch /var/log/wtmpx
	chown root.utmp /var/run/utmpx /var/log/wtmpx
	chmod 0660 /var/run/utmpx /var/log/wtmpx
else
	:>/var/run/utmp
	touch /var/log/wtmp
	chown root.utmp /var/run/utmp /var/log/wtmp
	chmod 0660 /var/run/utmp /var/log/wtmp
fi

# Clean /tmp
if is_yes "$CLEAN_TMP"; then
	rm -rf /tmp/* /tmp/.[a-zA-Z0-9]*
fi

# Right, now turn on swap in case we swap to files
swapon -a >/dev/null 2>&1
run_cmd "Enabling swap space" /bin/true

# If a SCSI tape has been detected, load the st module unconditionally
# since many SCSI tapes don't deal well with st being loaded and unloaded
if [ -f /proc/scsi/scsi ] && grep -q 'Type:   Sequential-Access' /proc/scsi/scsi 2>/dev/null ; then
	if cat /proc/devices | grep -qv ' 9 st' ; then
		if [ -n "$USEMODULES" ] ; then
			# Try to load the module. If it fails, ignore it...
			insmod -p st >/dev/null 2>&1 && modprobe -s st >/dev/null 2>&1
		fi
	fi
fi

# Load usb storage here, to match most other things
if [ -n "$needusbstorage" ]; then
        modprobe usb-storage >/dev/null 2>&1
fi

# There could be a new kernel version. Remove old psdevtab database
rm -f /etc/psdevtab

# Now that we have all of our basic modules loaded and the kernel going,
# let's dump the syslog ring somewhere so we can find it later
dmesg > /var/log/dmesg
chmod 640 /var/log/dmesg

kill -TERM $(/sbin/pidof getkey) >/dev/null 2>&1
} &
if is_yes "$PROMPT"; then
	/sbin/getkey i && touch /var/run/confirm
fi
wait
echo

# This must be last line !
# vi:syntax=sh:tw=78:ts=8:sw=4
